package CGI::Session::Serialize::default;use strict;use Safe;use Data::Dumper;use CGI::Session::ErrorHandler;use Scalar::Util qw(blessed reftype refaddr);use Carp"croak";use vars qw(%overloaded);require overload;@CGI::Session::Serialize::default::ISA=("CGI::Session::ErrorHandler");$CGI::Session::Serialize::default::VERSION='4.43';sub freeze{my($class,$data)=@_;my$d=new Data::Dumper([$data],["D"]);$d->Indent(0);$d->Purity(1);$d->Useqq(0);$d->Deepcopy(0);$d->Quotekeys(1);$d->Terse(0);return$d->Dump().';$D';}sub thaw{my($class,$string)=@_;my($safe_string)=$string=~m/^(.*)$/s;my$rv=Safe->new->reval($safe_string);if($@){return$class->set_error("thaw(): couldn't thaw. $@");}__walk($rv);return$rv;}sub __walk{my%seen;my@filter=__scan(shift);local%overloaded;while(@filter){defined(my$x=shift@filter)or next;$seen{refaddr$x||''}++and next;my$r=reftype$x or next;if($r eq"HASH"){push@filter,__scan(@{$x}{keys%$x});}elsif($r eq"ARRAY"){push@filter,__scan(@$x);}elsif($r eq"SCALAR"||$r eq"REF"){push@filter,__scan($$x);}}}sub __scan{for(@_){if(blessed$_){if(overload::Overloaded($_)){my$address=refaddr$_;if(exists$overloaded{$address}){$_=$overloaded{$address};}else{my$reftype=reftype$_;if($reftype eq"HASH"){$_=$overloaded{$address}=bless{%$_},ref$_;}elsif($reftype eq"ARRAY"){$_=$overloaded{$address}=bless[@$_],ref$_;}elsif($reftype eq"SCALAR"||$reftype eq"REF"){$_=$overloaded{$address}=bless\do{my$o=$$_},ref$_;}else{croak"Do not know how to reconstitute blessed object of base type $reftype";}}}else{bless$_,ref$_;}}}return@_;}1;__END__
